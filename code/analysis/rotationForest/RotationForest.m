classdef RotationForest < ExampleClassifier
    %ROTATION FOREST Rotation Forest implementation
    %
    % Implementation based on https://de.mathworks.com/matlabcentral/...
    % fileexchange/38792-rotation-forest-algorithm
    % 
    % Rotation Forest is an extension of Random Forest,
    % where new samples are generated by bootstrapping the original 
    % training set and transforming the features with PCA.
    %
    %% Properties
    %    numTrees ..... The number of trees used in the ensemble
    %    treeEnsemble . The ensemble itself, which is a TreeBagger object
    %    splitParameter .... The number of feature subsets
    %% Methods
    %    RotationForest .... Constructor with the possible arguments
    %                        .. numTrees (number of trees)
    %                        .. splitParameter (number of feature subsets)
    %
    %    trainOn .... See documentation in superclass Classifier.
    %    classifyOn . See documentation in superclass Classifier.
    %
    % Version: 2017-01-11
    % Author: Viola Hauffe
    %
    properties
        %number of trees in the ensemble
        numTrees;
        
        %the tree ensemble
        treeEnsemble;
        
        %how many feature subsets are going to be created
        splitParam;
        
        %the amount of bootsstrapped elements taken from the dataset
        bootstrapParam;
        
        featureList;
        labelList;
    end
    
    methods
        
        function obj = RotationForest(numTrees,splitParameter)
            %specify how many trees should be learned
            obj.numTrees = numTrees;
            obj.splitParam = splitParameter;
            obj.bootstrapParam = 0.75; %%default value
        end
          function str = toString(obj)
           str = ['RotationForest (numTrees: ' int2str(obj.numTrees) ', splitParam:' int2str(obj.splitParam) ')'];  
        end
        
        function str = toShortString(obj)
            str = ['RotationForest_' int2str(obj.numTrees) '' int2str(obj.splitParam)];
        end
        function obj = trainOn(obj, trainFeatureCube, trainLabelMap)
            % Extract labeled pixels
            obj.featureList = validListFromSpatial(...
                trainFeatureCube, trainLabelMap, true);
            obj.labelList = validListFromSpatial(...
                trainLabelMap, trainLabelMap, true);
            
            [~,numFeatures] = size(obj.featureList);
            if(obj.splitParam > numFeatures)
                error('splitParameter has to be less than the number of features');
            end
%             for l=1:obj.numTrees
%                 %%% obtain the new samples by rotation forest %%%
%                 K=obj.splitParam;
%                 [R_new,R_coeff]=RotationFal(featureList, labelList, K,...
%                     obj.bootstrapParam);
%                 %%%% obtain new samples %%%%
%                 trainRFnew=featureList*R_coeff;
%                 tree = TreeBagger(1,trainRFnew,labelList);
%                 if(l == 1)
%                      obj.treeEnsemble = tree;
%                 else
%                      obj.treeEnsemble.append(tree);
%                 end
%             end
        end
            
            function predictedLabelMap = classifyOn(...
                obj, evalFeatureCube, maskMap)
            
           % Extract list of unlabeled pixels
            featList = validListFromSpatial(evalFeatureCube, maskMap);
            labelMat = zeros(size(featList,1),obj.numTrees);
             for l=1:obj.numTrees
                %%% obtain the new samples by rotation forest %%%
                K=obj.splitParam;
                [R_new,~]=RotationFal(obj.featureList, obj.labelList, K,...
                    obj.bootstrapParam);
                %%%% obtain new samples %%%%
                trainRFnew=obj.featureList*R_new;

                tree = fitctree(trainRFnew,obj.labelList);
                labelMat(:,l) = tree.predict(featList*R_new);
                
            end
%             % Predict labels using the ensemble
%             predictedLabelList = obj.treeEnsemble.predict(featureList);
%             
%             % TreeBagger output is a cell array -> transform to matrix
%             predictedLabelList = cellfun(@(x) str2num(x), predictedLabelList);
            predictedLabelList = (mode(labelMat'))';
            % Rebuild map representation
            predictedLabelMap = rebuildMap(predictedLabelList, maskMap);
            end
        end
        
end
    



